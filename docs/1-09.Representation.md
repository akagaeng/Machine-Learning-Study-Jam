# 특성 추출

## 원시 데이터를 특성에 매핑

### 비정제 데이터의 예
```
0: {
    house_info: {
        num_rooms: 6,
        num_bedrooms: 3,
        street_name: "Shorebird Way",
        num_basement_rooms: -1
    }
}
```

### 정제 데이터의 예
```
[
    6.0,
    1.0,
    0.0,
    9.321,
    -2.20,
    ...
]
```

### 특성(feature) 추출
- 비정제 데이터(원시 데이터)에서 정제 데이터(피쳐 벡터)로 변환하는 과정
- 특성 벡터는 `부동소수점 값`의 집합으로 이루어져 있다!
- 일반적으로 상당히 시간이 소요되는 작업!

## 숫자 값 매핑
- 비정제 데이터가 실수, 정수인 경우는 바로 피쳐값으로 사용 가능

## 문자열 값 매핑
### 원-핫 인코딩 만들기
- 문자열이 "Shorebird Way"인 경우, 해당 데이터세트의 종류가 10개라고 하면 1개만 1이고 나머지는 다 0으로 셋팅

## 범주형(열거형) 값 매핑
```
Lowland Countries = {
    'Netherlands', 
    'Belgium', 
    'Luxembourg'
}
```

- 서로 다른 값을 나타내는 정수의 이산집합으로 인코딩
```
'Netherlands' => 0
'Belgium'     => 1
'Luxembourg'  => 2
```

- 서로 다른 부울 특성으로 표현
  + 이산집합으로 인코딩 했을 때에는 각각이 하나의 특성으로 표현되나, 서로 다른 부울 특성으로 표현한 경우에는 두가지 이상의 조건을 만족하는 특성도 찾을 수 있다.
  + ex) 프랑스의 접경국? 벨기에, 룩셈부르크 모두 찾을 수 있음 (xk: 접경국? true/false 로 설정해둔 경우)
```
x1: 'Netherlands'?  true(1) / false(0)
x2: 'Belgium'?      true(1) / false(0)
x3: 'Luxembourg'?   true(1) / false(0)

[1,0,0] => 네덜란드
[0,1,0] => 벨기에
[0,0,1] => 룩셈부르크
```

## 좋은 특성의 조건
1. 거의 사용되지 않는 불연속 특성 값 배제
  + 데이터 세트에서 최소 5회 이상 나타나는 특성이 좋음
2. 가급적 분명하고 명확한 의미 부여
  + age: 27       OK (누가 봐도 나이)
  + age: 85142000 X  (누군가가 보면 나이)
3. 특수 값을 실제 데이터와 혼용하지 말 것
  + false값 대신 `-1`을 입력한 경우 bool값인지 실수값인지 혼동하지 않도록 하기
  + 변수명에 is_quality_rating_defined 와 같이 bool 값이 들어갈 데이터 구분하기
4. 업스트림 불안정성 고려
  + 특성의 정의는 시간이 지나도 변하지 않아야 한다.
  + 상파울루를 나타내는 수가 이 모델에서는 219이고 다른 모델에서는 다른 값을 가지면 안된다.


## 데이터 정제
좋지 않은 데이터 몇 개가 거대한 데이터 세트를 망칠 수 있다.

### 특성 값 조정
#### 조정
- 부동 소수점 특성 값을 0~1 또는 -1~+1 등의 표준 범위로 변환하는 작업
- 특성 세트가 여러 특성으로 구성되어있다면 
  + 경사하강법이 더 빠르게 수렴
  + NaN 트랩이 방지된다.
    * NaN 트랩: 부동소수점 정밀도 한도 초과한 경우 모델의 다른 숫자가 결국 NaN이 되는 현상
  + 모델이 각 특성의 적절한 가중치를 익히는 데 도움이 된다.
    * 특성 조정을 하지 않으면 범위가 더 넓은 특성을 과도하게 중요시하게 된다.

Z점수 계산: 숫자 데이터 조정하는 방법
```
scale_value = (value - mean) / std_dev
```

### 극단적 이상점 처리
너무 크거나 너무 작은 값 제거
- 모든 값에 로그를 취한다.
- 임의의 지점에서 특성값 잘라낸다.

### 비닝 (버케팅)
- 연속된 하나의 특성을 버킷(bucket) 또는 빈(bin)이라고 하는 여러 이진 특성으로 변환하는 작업
- 온도 0~50도 사이인 경우
  + 00.0~15.0도 => 1번 빈
  + 15.1~30.0도 => 2번 빈
  + 30.1~50.0도 => 3번 빈

### 스크러빙(씻다/청소하다)
데이터 세트의 일부를 신뢰하지 못하여 일부부를 삭제하여 데이터세트를 수정하는 것

잘못된 개별 예 탐지
- 값 누락
- 중복된 값
- 잘못된 라벨
- 잘못된 특성 값

잘못된 데이터(전체적인 관점) 탐지
- min, max, median, mean, std_dev 지표 활용
- 히스토그램 활용

### 철저한 데이터 파악
- 정상적인 데이터가 어떠한 모습이어야 하는지 항상 생각하기
- 데이터가 예상과 일치하는지 확인하고, 불일치시 이유 파악하기
- 학습 데이터가 대시보드 등의 다른 소스와 일치하는지 확인하기


## 프로그래밍 실습

### 작업 1: 효율적인 특성 세트 개발

상관성 파악
- 각 특성을 다른 특성(일부 타겟)과 비교
- 피어슨 상관계수(Pearson correlation coefficient)로 상관성 파악
  + +1.0: 완벽한 양의 상관성
  +  0.0: 상관성 없음
  + -1.0: 완벽한 음의 상관성
- 타겟과 상관성이 높은 특성 위주로 특성으로 선택

```
median_house_value를 예측하는 모델
```

작업1에서는 target과 상관성이 높은 median_income, rooms_per_person이 특성으로 포함되면 성능이 향상될 것 같다.

> median_income, latitude를 넣었더니 RMSE가 112정도 까지 줄어들었음 (모든 특성을 사용했을 때보다 성능 더 좋음(130대였음))

> median_income, rooms_per_person을 넣었더니 RMSE가 85.16까지 줄어들었음

#### latitude를 잘 활용할 수 있는 합성특성 만들기
- 표로 그려보면 위도는 median_house_value와 크게 선형관계 없음
  + 그런데 36도 지역, 40도 이후 지역이 값이 많이 없는 것을 발견하였음!
- 위도를 더 잘 활용하도록 버킷화(`Series.apply` 사용)

> median_income, 버킷화한 latitude로 학습시킨 결과 RMSE가 83.32까지 떨어졌음

```
동일한 데이터도 가공하기에 따라 필요한 데이터가 될 수도 있고, 필요없는 데이터가 될수도 있다.
```
